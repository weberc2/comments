package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"testing"
	"time"

	pz "github.com/weberc2/httpeasy"
)

func TestPutComment(t *testing.T) {
	now := time.Date(2022, 1, 1, 0, 0, 0, 0, time.UTC)
	for _, testCase := range []struct {
		name         string
		input        string
		wantedStatus int
		wantedBody   Wanted
	}{
		{
			name:         "creates comment",
			input:        `{"body": "great comment"}`,
			wantedStatus: http.StatusCreated,
			wantedBody: &Comment{
				ID:       "comment",
				Author:   "user",
				Parent:   "",
				Created:  now,
				Modified: now,
				Body:     "great comment",
			},
		},
		{
			// If the caller tries to pass explicit values for id, author,
			// created, or modified fields, these fields are ignored in favor
			// of authoritative sources (`id` is generated by the underlying
			// CommentStore, `author` defers to the `User` header, and
			// `created` and `modified` are set to the current time).
			name: "ignores id, author, created, modified",
			input: `{
	"id": "asdf",
	"author": "foo",
	"body": "great comment",
	"created": "1970-01-01T00:00:00.000000Z",
	"modified": "1970-01-01T00:00:00.000000Z"
}`,
			wantedStatus: http.StatusCreated,
			wantedBody: &Comment{
				ID:       "comment",
				Author:   "user",
				Body:     "great comment",
				Parent:   "",
				Created:  now,
				Modified: now,
			},
		},
		{
			name:         "minimum body size",
			input:        `{"body": ""}`,
			wantedStatus: http.StatusBadRequest,
			wantedBody:   &ErrBodyTooShort,
		},
		{
			name: "maximum body size",
			input: fmt.Sprintf(
				`{"body": "%s"}`,
				strings.Repeat("s", bodySizeMax+1),
			),
			wantedStatus: http.StatusBadRequest,
			wantedBody:   &ErrBodyTooLong,
		},
		{
			name:         "html escape",
			input:        `{"body": "<script></script>"}`,
			wantedStatus: http.StatusCreated,
			wantedBody: &Comment{
				ID:       "comment",
				Author:   "user",
				Body:     "&lt;script&gt;&lt;/script&gt;",
				Parent:   "",
				Created:  now,
				Modified: now,
			},
		},
	} {
		t.Run(testCase.name, func(t *testing.T) {
			commentsService := CommentsService{
				Comments: &ObjectCommentsStore{
					ObjectStore: objectStoreFake{},
					PostStore:   &postStoreFake{"post"},
					Bucket:      "bucket",
					Prefix:      "prefix",
					IDFunc:      func() CommentID { return "comment" },
				},
				TimeFunc: func() time.Time { return now },
			}

			rsp := commentsService.PutComment(pz.Request{
				Vars:    map[string]string{"post-id": "post"},
				Headers: http.Header{"User": []string{"user"}},
				Body:    strings.NewReader(testCase.input),
			})

			if rsp.Status != testCase.wantedStatus {
				data, err := readAll(rsp.Data)
				if err != nil {
					t.Logf("error reading response body: %v", err)
				}
				for _, logging := range rsp.Logging {
					data, err := json.Marshal(logging)
					if err != nil {
						t.Logf("error marshalling logging as JSON: %v", err)
					}
					t.Logf("log: %s", data)
				}
				t.Fatalf(
					"Response.Status: wanted `%d`; found `%d`: %s",
					testCase.wantedStatus,
					rsp.Status,
					data,
				)
			}

			data, err := readAll(rsp.Data)
			if err != nil {
				t.Fatalf("Response.Data: reading serializer: %v", err)
			}

			if err := testCase.wantedBody.Compare(data); err != nil {
				t.Errorf("Response.Data: %v", err)
				t.Logf("Actual body: %s", data)
			}
		})
	}
}

func readAll(s pz.Serializer) ([]byte, error) {
	writerTo, err := s()
	if err != nil {
		return nil, fmt.Errorf("serializing: %w", err)
	}

	var b bytes.Buffer
	if _, err := writerTo.WriteTo(&b); err != nil {
		return nil, fmt.Errorf("copying data to buffer: %w", err)
	}

	return b.Bytes(), nil
}

func (c *Comment) compare(other *Comment) error {
	if c == nil && other == nil {
		return nil
	}

	if c != nil && other == nil {
		return fmt.Errorf("Comment: unexpected `nil`")
	}

	if c == nil && other != nil {
		return fmt.Errorf("Comment: wanted `nil`; found not-nil")
	}

	if c.ID != other.ID {
		return fmt.Errorf(
			"Comment.ID: wanted `%s`; found `%s`",
			c.ID,
			other.ID,
		)
	}

	if c.Author != other.Author {
		return fmt.Errorf(
			"Comment.Author: wanted `%s`; found `%s`",
			c.Author,
			other.Author,
		)
	}

	if c.Parent != other.Parent {
		return fmt.Errorf(
			"Comment.Parent: wanted `%s`; found `%s`",
			c.Parent,
			other.Parent,
		)
	}

	if c.Body != other.Body {
		return fmt.Errorf(
			"Comment.Body: wanted `%s`; found `%s`",
			c.Body,
			other.Body,
		)
	}

	if c.Created != other.Created {
		return fmt.Errorf(
			"Comment.Created: wanted `%s`; found `%s`",
			c.Created,
			other.Created,
		)
	}

	if c.Modified != other.Modified {
		return fmt.Errorf(
			"Comment.Modified: wanted `%s`; found `%s`",
			c.Modified,
			other.Modified,
		)
	}

	return nil
}

type Wanted interface {
	Compare([]byte) error
}

func (wanted *Comment) Compare(data []byte) error {
	var other Comment
	if err := json.Unmarshal(data, &other); err != nil {
		return fmt.Errorf("unmarshaling `Comment`: %w", err)
	}
	return wanted.compare(&other)
}

func (wanted *HTTPError) Compare(data []byte) error {
	var other HTTPError
	if err := json.Unmarshal(data, &other); err != nil {
		return fmt.Errorf("unmarshaling `HTTPError`: %w", err)
	}
	if wanted.Status != other.Status {
		return fmt.Errorf(
			"HTTPError.Status: wanted `%d`; found `%d`",
			wanted.Status,
			other.Status,
		)
	}
	if wanted.Message != other.Message {
		return fmt.Errorf(
			"HTTPError.Message: wanted `%s`; found `%s`",
			wanted.Message,
			other.Message,
		)
	}
	return nil
}
